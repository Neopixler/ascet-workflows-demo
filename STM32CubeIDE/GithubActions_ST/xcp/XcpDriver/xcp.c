/**
*
* \file
*
* \brief XCP slave driver initialisation and command processor.
*
* Copyright ETAS GmbH, Stuttgart.
*
* This file is covered by the licence and disclaimer document which is installed with
* the XCP ECU software package.
*
* \version $Id: xcp.c 22424 2011-04-27 09:40:17Z olcritch $
*
******************************************************************************/

#include "xcp_common.h"
#include "xcp_inf.h"
#include "xcp_auto_confdefs.h"
#include "xcp_priv.h"
#include "xcp_auto_confpriv.h"
#if defined( XCP_ON_CAN )
    #include "xcpcan_pub.h"
    #include "xcpcan_auto_confpriv.h"
#elif defined( XCP_ON_IP )
    #include "xcpip_pub.h"
    #include "xcpip_auto_confpriv.h"
#endif
#ifndef XCP_V_1_0_5
#error This file is being compiled with code generated by an incorrect version of the XCP ECU Software configuration tool. Please re-generate code using the correct version of the configuration tool.
#endif

#ifdef XCP_ENABLE

/**************************************************************************************************/
/*                                                                                                */
/* Xcp Services                                                                                   */
/*                                                                                                */
/**************************************************************************************************/

uint XCP_FN_TYPE (*const Xcp_CmdList[])( uint             sessionCfgIdx,
                                         Xcp_Packet_t*    pRxPacket,
                                         Xcp_Packet_t*    pTxPacket,
                                         uint             prevCmd,
                                         uint*            pTxPacketSize ) =
{
    /* Standard commands                                     */
    Xcp_CmdConnect,          /* CONNECT                 0xFF */
    Xcp_CmdDisconnect,       /* DISCONNECT              0xFE */
    Xcp_CmdGetStatus,        /* GET_STATUS              0xFD */
    Xcp_CmdSynch,            /* SYNCH                   0xFC */
    Xcp_CmdGetCommModeInfo,  /* GET_COMM_MODE_INFO      0xFB */
    Xcp_CmdGetId,            /* GET_ID                  0xFA */
    Xcp_CmdSetRequest,       /* SET_REQUEST             0xF9 */
    Xcp_CmdGetSeed,          /* GET_SEED                0xF8 */
    Xcp_CmdUnlock,           /* UNLOCK                  0xF7 */
    Xcp_CmdSetMta,           /* SET_MTA                 0xF6 */
    Xcp_CmdUpload,           /* UPLOAD                  0xF5 */
    Xcp_CmdShortUpload,      /* SHORT_UPLOAD            0xF4 */
    Xcp_CmdBuildChecksum,    /* BUILD_CHECKSUM          0xF3 */
    Xcp_CmdTransportLayer,   /* TRANSPORT_LAYER_CMD     0xF2 */
    Xcp_CmdUser,             /* USER_CMD                0xF1 */

    /* Calibration commands                                  */
    Xcp_CmdDownload,         /* DOWNLOAD                0xF0 */
    Xcp_CmdDownloadNext,     /* DOWNLOAD_NEXT           0xEF */
    Xcp_CmdDownloadMax,      /* DOWNLOAD_MAX            0xEE */
    Xcp_CmdUnknown,          /* SHORT_DOWNLOAD          0xED */
    Xcp_CmdModifyBits,       /* MODIFY_BITS             0xEC */

    /* Page switching commands                               */
    Xcp_CmdSetCalPage,       /* SET_CAL_PAGE            0xEB */
    Xcp_CmdGetCalPage,       /* GET_CAL_PAGE            0xEA */
    Xcp_CmdGetPagProcInfo,   /* GET_PAG_PROCESSOR_INFO  0xE9 */
    Xcp_CmdUnknown,          /* GET_SEGMENT_INFO        0xE8 */
    Xcp_CmdUnknown,          /* GET_PAGE_INFO           0xE7 */
    Xcp_CmdSetSegmentMode,   /* SET_SEGMENT_MODE        0xE6 */
    Xcp_CmdGetSegmentMode,   /* GET_SEGMENT_MODE        0xE5 */
    Xcp_CmdCopyCalPage,      /* COPY_CAL_PAGE           0xE4 */

    /* Data Acquisition and Stimulation commands             */
    Xcp_CmdClearDaqList,     /* CLEAR_DAQ_LIST          0xE3 */
    Xcp_CmdSetDaqPtr,        /* SET_DAQ_PTR             0xE2 */
    Xcp_CmdWriteDaq,         /* WRITE_DAQ               0xE1 */
    Xcp_CmdSetDaqListMode,   /* SET_DAQ_LIST_MODE       0xE0 */
    Xcp_CmdGetDaqListMode,   /* GET_DAQ_LIST_MODE       0xDF */
    Xcp_CmdStartStopDaqList, /* START_STOP_DAQ_LIST     0xDE */
    Xcp_CmdStartStopSync,    /* START_STOP_SYNCH        0xDD */
    Xcp_CmdGetDaqClock,      /* GET_DAQ_CLOCK           0xDC */
    Xcp_CmdUnknown,          /* READ_DAQ                0xDB */
    Xcp_CmdGetDaqProcInfo,   /* GET_DAQ_PROCESSOR_INFO  0xDA */
    Xcp_CmdGetDaqResInfo,    /* GET_DAQ_RESOLUTION_INFO 0xD9 */
    Xcp_CmdGetDaqListInfo,   /* GET_DAQ_LIST_INFO       0xD8 */
    Xcp_CmdUnknown,          /* GET_DAQ_EVENT_INFO      0xD7 */
    Xcp_CmdFreeDaq,          /* FREE_DAQ                0xD6 */
    Xcp_CmdAllocDaq,         /* ALLOC_DAQ               0xD5 */
    Xcp_CmdAllocOdt,         /* ALLOC_ODT               0xD4 */
    Xcp_CmdAllocOdtEntry,    /* ALLOC_ODT_ENTRY         0xD3 */

    /* Non-volatile memory programming commands              */
    Xcp_CmdProgramStart,     /* PROGRAM_START           0xD2 */
    Xcp_CmdProgramClear,     /* PROGRAM_CLEAR           0xD1 */
    Xcp_CmdProgram,          /* PROGRAM                 0xD0 */
    Xcp_CmdProgramReset,     /* PROGRAM_RESET           0xCF */
    Xcp_CmdUnknown,          /* GET_PGM_PROCESSOR_INFO  0xCE */
    Xcp_CmdUnknown,          /* GET_SECTOR_INFO         0xCD */
    Xcp_CmdProgramPrepare,   /* PROGRAM_PREPARE         0xCC */
    Xcp_CmdProgramFormat,    /* PROGRAM_FORMAT          0xCB */
    Xcp_CmdProgramNext,      /* PROGRAM_NEXT            0xCA */
    Xcp_CmdProgramMax,       /* PROGRAM_MAX             0xC9 */
    Xcp_CmdUnknown,          /* PROGRAM_VERIFY          0xC8 */
};
#define XCP_LOWEST_CMD_PID 0xc8

#ifdef XCP_ENABLE_RESUME

/**
 * This function performs RESUME for a session by restoring the session's state from non-volatile (NV) memory and
 * transmitting the event EV_RESUME_MODE.
 *
 * \param [in] sessionId        The ID of the session being RESUMEd.
 * \param [in] pSessionCfg      The configuration of the session being RESUMEd.
 * \param [in] pSession         The state of the session being RESUMEd.
 */
void XCP_FN_TYPE Xcp_DoResume(
    uint                  sessionId,
    Xcp_SessionConfig_t*  pSessionCfg,
    Xcp_Session_t*        pSession
)
{
    typedef XCP_PACK( struct
    {
        uint8  pid;
        uint8  eventId;
        uint16 sessionConfigId;
        uint32 timestamp;
    } ) EventPacket_t;

    uint                  nvIdx       = pSessionCfg->nvStartIdx;
    Xcp_NvSession_t       nvSession;
    Xcp_NvDaqState_t      nvDaqState;
    Xcp_Daq_t*            pDaqState;
    Xcp_DaqConfig_t*      pDaqConfig;
    uint                  numOdtEntries;
    EventPacket_t*        pEventPacket;

    /* The non-volatile (NV) memory region for the session begins with an instance of Xcp_NvSession_t.
     *
     * This will not be present if none of the DAQ lists in the session are in RESUME mode. */

    XcpApp_NvMemRead( nvIdx, (Xcp_StatePtr8)&nvSession, sizeof_Xcp_NvSession_t );
    nvIdx += sizeof_Xcp_NvSession_t;

    if( XCP_NVMEM_MAGIC_NUMBER != nvSession.magicNumber )
    {
        /* There is no configuration stored for this session in NV memory; RESUME mode is not active. */
        return;
    }

    pSession->sessionCfgId    = nvSession.sessionCfgId;
    pSession->numDynDaqLists  = nvSession.numDynDaqLists;
    pSession->sessionStatus   = XCP_SESSION_STATE_RESUME | XCP_SESSION_STATE_DAQ_RUNNING;

    /* Next the NV memory region contains a block of data for each DAQ list which has been selected for RESUME. */
    for( ; 0 != nvSession.numResumeDaqLists; --nvSession.numResumeDaqLists )
    {
        /* Read data which is common to static and dynamic DAQ lists. */

        XcpApp_NvMemRead( nvIdx, (Xcp_StatePtr8)&nvDaqState, sizeof_Xcp_NvDaqState_t );
        nvIdx += sizeof_Xcp_NvDaqState_t;

        pDaqConfig              = pSessionCfg->pDaqConfigs + nvDaqState.daqListId;
        pDaqState               = pSessionCfg->pDaqStates + nvDaqState.daqListId;
        pDaqState->daqEvent     = nvDaqState.daqEvent;
        pDaqState->maxOdtIdUsed = nvDaqState.maxOdtIdUsed;
        pDaqState->daqListMode  = nvDaqState.daqListMode | XCP_DAQLISTMODE_RUNNING;

#ifdef XCP_ENABLE_DYNDAQ
        /* If the current session uses dynamic DAQ lists, read the dynamic portion of the DAQ lists's configuration. */
        if( pSessionCfg->pDaqDynConfigs )
        {
            XcpApp_NvMemRead( nvIdx, (Xcp_StatePtr8)( pSessionCfg->pDaqDynConfigs + nvDaqState.daqListId ), sizeof_Xcp_DaqDynConfig_t );
            nvIdx += sizeof_Xcp_DaqDynConfig_t;
        }
#endif /* XCP_ENABLE_DYNDAQ */

        /* Read the addresses and lengths assigned to each ODT entry in each currently-used ODT in the DAQ list. */

        numOdtEntries = pDaqConfig->numOdtEntries * ( pDaqState->maxOdtIdUsed + 1 );

        XcpApp_NvMemRead( nvIdx, (Xcp_StatePtr8)( pSessionCfg->pOdtEntryAddrs + pDaqConfig->idxDaqStart ), numOdtEntries * sizeof( Xcp_OdtEntryAddr_t ) );
        nvIdx += numOdtEntries * sizeof( Xcp_OdtEntryAddr_t );

        XcpApp_NvMemRead( nvIdx, (Xcp_StatePtr8)( pSessionCfg->pOdtEntryCfgs + pDaqConfig->idxDaqStart ), numOdtEntries );
        nvIdx += numOdtEntries;

        /* Allow the transport layer to read data for this DAQ list. */
        nvIdx += pSessionCfg->pDoResume( sessionId, nvDaqState.daqListId, nvIdx );
    }

    /* Transmit EV_RESUME_MODE using the currently-configured timestamp resolution. */

    pEventPacket = (EventPacket_t*)( (pSessionCfg->pGetTxBuf)( sessionId, XCP_TX_EVENT_CHANNEL ) );
    if( pEventPacket )
    {
        pEventPacket->pid             = XCP_PID_EVENT;
        pEventPacket->eventId         = XCP_EV_RESUME_MODE;
        pEventPacket->sessionConfigId = pSession->sessionCfgId;

        if( 0 != pSessionCfg->numBytesTimestamp )
        {
            Xcp_GetTimestamp( (Xcp_StatePtr8)&( pEventPacket->timestamp ), pSessionCfg->numBytesTimestamp );
        }

        (pSessionCfg->pTxNext)( sessionId, XCP_TX_EVENT_CHANNEL, 4 + pSessionCfg->numBytesTimestamp );
    }
}

#endif /* XCP_ENABLE_RESUME */

/**
 * This function initializes the XCP slave driver. It must be called exactly once.
 */
void XCP_FN_TYPE Xcp_Initialize( void )
{
    uint                  j;
    uint                  i;
    Xcp_Daq_t*            pDaqState;
    Xcp_DaqConfig_t*      pDaqConfig;
    Xcp_SessionConfig_t*  pSessionCfg = Xcp_SessionConfigs;
    Xcp_Session_t*        pSession    = Xcp_Sessions;

    /* Initialise the transport layer. This must be done before initialising our sessions, in case we wish to
     * RESUME a session thereby (possibly) modifying the state of the transport layer. */
#if defined( XCP_ON_CAN )
    XcpCan_Initialize();
#elif defined( XCP_ON_IP )
    XcpIp_Initialize();
#endif

    /* Initialize the state of all sessions and DAQ lists. */

    for( i = 0; i < XCP_NUM_SESSIONS; ++i )
    {
        pSession->ctDaqListId           = XCP_DAQLIST_UNDEF;
#ifdef XCP_ENABLE_SEEDNKEY
        pSession->ctResourceProtection  = pSessionCfg->defResourceProtection;
#endif /* XCP_ENABLE_SEEDNKEY */

        pDaqState = pSessionCfg->pDaqStates;
        pDaqConfig = pSessionCfg->pDaqConfigs;

        for( j = 0; j < (uint)pSessionCfg->numStatDaqLists; ++j )
        {
            pDaqState->daqListMode = 0;

            /* Set an appropriate default direction for the DAQ list.
             * (If the DAQ list supports both DAQ and STIM we default to DAQ). */
            if( pDaqConfig->properties & XCP_DAQLISTPROPERTY_DAQ )
            {
                pDaqState->daqListMode &= ~XCP_DAQLISTMODE_DIRECTION;
            }
            else
            {
                pDaqState->daqListMode |= XCP_DAQLISTMODE_DIRECTION;
            }

            /* Initialise the DAQ list's default event. */
            pDaqState->daqEvent = pDaqConfig->defaultEvent;

            ++pDaqState;
            ++pDaqConfig;
        }

#ifdef XCP_ENABLE_RESUME
        /* If this session can be RESUMEd, check for RESUME data in non-volatile memory and execute the RESUME if necessary. */
        if( XCP_INVALID_NV_IDX != pSessionCfg->nvStartIdx )
        {
            Xcp_DoResume( i, pSessionCfg, pSession );
        }
#endif /* XCP_ENABLE_RESUME */

        ++pSessionCfg;
        ++pSession;
    }

	return;
}

/**
 * This function reads a command message from the command channel (provided by the transport layer), processes it, and,
 * if possible, sends a response on the response channel.
 * If a response cannot be sent in a suitably timely manner the functions sends the event EV_CMD_PENDING.
 */
void XCP_FN_TYPE Xcp_CmdProcessor( void )
{
    uint                  sessionId;
    Xcp_SessionConfig_t*  pSessionCfg = Xcp_SessionConfigs;
    Xcp_Session_t*        pSession    = Xcp_Sessions;
    uint                  pid;

    for( sessionId = 0; sessionId < XCP_NUM_SESSIONS; ++sessionId )
    {
        Xcp_Packet_t* pRxPacket;
        Xcp_Packet_t* pTxPacket;

        pRxPacket = (Xcp_Packet_t*)( ( pSessionCfg->pGetRxBuf )( sessionId, XCP_RX_CMD_CHANNEL ) );
        pTxPacket = (Xcp_Packet_t*)( ( pSessionCfg->pGetTxBuf )( sessionId, XCP_TX_CRM_CHANNEL ) );

        if( pRxPacket && pTxPacket )
        {
            uint cmdResult = 0;
            uint txPacketSize = 0;

            pid = pRxPacket->pid;

            /* Process all commands received while the session is connected, plus CONNECT and TRANSPORT_LAYER_CMD
             * at all times. */

            if( pSession->isConnected ||
                pid == XCP_CMD_CONNECT ||
                pid == XCP_CMD_TRANSPORT_LAYER_CMD )
            {
                Xcp_StatePtr8 pPrevCmd = &( pSession->prevCmd );

                if( *pPrevCmd != XCP_CMD_CURR_CMD )
                {
                    /* We have received a new command packet (i.e. we are not re-processing a pending command packet),
                     * so we restart the timeout counter. */
                    pSession->timeoutCounter = 0;
                }

                /* If:
                 *  - we are in the middle of either a download block sequence or a flash block sequence;
                 *  - and:
                 *      - either the current command is not DOWNLOAD_NEXT or PROGRAM_NEXT;
                 *      - or DOWNLOAD_NEXT has been received in the middle of a flash sequence;
                 *      - or PROGRAM_NEXT has been received in the middle of a download sequence.
                 */
                if( pSession->downloadRemainBytes > 0 &&
                    ( !( pid == XCP_CMD_DOWNLOAD_NEXT || pid == XCP_CMD_PROGRAM_NEXT ) ||
                      ( pid == XCP_CMD_DOWNLOAD_NEXT && *pPrevCmd != XCP_CMD_DOWNLOAD_NEXT && *pPrevCmd != XCP_CMD_DOWNLOAD ) ||
                      ( pid == XCP_CMD_PROGRAM_NEXT && *pPrevCmd != XCP_CMD_PROGRAM_NEXT && *pPrevCmd != XCP_CMD_PROGRAM ) ) )
                {
                    /* Clear downloadRemainBytes so that next DOWNLOAD_NEXT or PROGRAM_NEXT will produce a sequence error
                     * if block mode not restarted. */
                    pSession->downloadRemainBytes = 0;

                    /* We continue to process the command which caused the interruption. */
                }

                if( pid >= XCP_LOWEST_CMD_PID )
                {
                    /* Command is in the table of known commands. */
#ifdef XCP_ENABLE_SEEDNKEY
                    uint requiredResources;

                    if( pid > MAX_CALPAGCMD_PID )
                    {
                        /* Command is in the "standard" group of commands. */
                        requiredResources = 0;
                    }
                    else if( pid > MAX_DAQCMD_PID )
                    {
                        /* Command is in the "CALPAG" group of commands. */
                        requiredResources = XCP_RESOURCE_CAL_PAG;
                    }
                    else if( pid > MAX_PGMCMD_PID )
                    {
                        /* Command is in the "DAQ" group of commands. */
                        requiredResources = XCP_RESOURCE_DAQ;
                    }
                    else
                    {
                        /* Command is in the "PGM" group of commands. */
                        requiredResources = XCP_RESOURCE_PGM;
                    }

                    if( requiredResources & (uint)pSession->ctResourceProtection )
                    {
                        /* At least one of the resources required by the command is locked in the current session. */
                        pTxPacket->data[0]  = XCP_ERR_ACCESS_LOCKED;
                        pTxPacket->pid      = XCP_PID_ERROR;
                        txPacketSize        = 2;
                        cmdResult           = XCP_RX_READY | XCP_TX_READY;
                    }
                    else
#endif /* XCP_ENABLE_SEEDNKEY */
                    {
                        /* All the resources required by the command are available and unlocked; execute the command. */
                        cmdResult = (Xcp_CmdList[ XCP_PID_CMD_FIRST - pid ])( sessionId, pRxPacket, pTxPacket, *pPrevCmd, &txPacketSize );
                    }
                }
                else
                {
                    /* Command is not in the table of known commands. */
                    cmdResult = Xcp_CmdUnknown( sessionId, pRxPacket, pTxPacket, *pPrevCmd, &txPacketSize );
                }

                if( cmdResult != 0ul )
                {
                    /* We have finished processing the current command; remember its PID. */
                    *pPrevCmd = (uint8)pid;
                }
                else
                {
                    /* We have not yet finished processing the current command. The current will remain pending,
                     * i.e. the next time this function is called it will retrieve and process the same command from
                     * the transport layer. */
                    *pPrevCmd = XCP_CMD_CURR_CMD;
                }
            }
            else
            {
                /* We are not connected so we dismiss the message. */
                cmdResult = XCP_RX_READY;
            }

            if( cmdResult & XCP_RX_READY )
            {
                /* We are finished with the rx buffer; mark it as read. */
                (pSessionCfg->pRxNext)( sessionId, XCP_RX_CMD_CHANNEL );
            }

            if( cmdResult & XCP_TX_READY )
            {
                /* We are finished with the tx buffer; mark it as ready for transmission. */
                (pSessionCfg->pTxNext)( sessionId, XCP_TX_CRM_CHANNEL, txPacketSize );
            }

            /* Check whether we need to send a PENDING event to the XCP master to prevent the master from
             * timing out.
             *
             * The master measures its timeout interval from the point it transmits the last packet of a
             * command to the point it receives the last packet of the response. This implies that:
             *
             *  - In master block mode the master's timer is restarted every time a block is sent by the master.
             *
             *  - In slave block mode, the master's timer is *not* restarted every time a block is received from
             *    the slave, only when the last block is received.
             *    Therefore we may need to send a PENDING event even though we are also sending a non-final
             *    response packet.
             *
             * Note that:
             *
             *  - Our timeout calculation cannot take into account the interval of time between the command message
             *    being sent from the master and it arriving in this function. In particular, the command message
             *    may linger for some while in the transport layer's RX queue.
             *
             *  - We check for timeout of the current command even when receiving STIM messages
             */

            if( pSession->timeoutCounter >= (uint32)pSessionCfg->eventPendingTimeout )
            {
                Xcp_Packet_t* pEventPacket = (Xcp_Packet_t*)( (pSessionCfg->pGetTxBuf)( sessionId, XCP_TX_EVENT_CHANNEL ) );
                if( pEventPacket )
                {
                    /* Transmit event message */
                    pEventPacket->data[0]   = XCP_EV_CMD_PENDING;
                    pEventPacket->pid       = XCP_PID_EVENT;

                    (pSessionCfg->pTxNext)( sessionId, XCP_TX_EVENT_CHANNEL, 2 );

                    /* Reset timeout counter */
                    pSession->timeoutCounter = 0;
                }
            }
            else
            {
                ++( pSession->timeoutCounter );
            }
        }

        ++pSessionCfg;
        ++pSession;
    }

    return;
}

#endif /* XCP_ENABLE */
